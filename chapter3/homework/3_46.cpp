#include <stdio.h>
#include <malloc.h>
#include <string.h>


/*
	This is very low-quality code.
	It is intended to illustrate bad programming practises.
	see Practice Problem 3.46

*/

/*
	A. 

	0x10 = 16

  | ------------------------ |
  | 00 00 00 00 00 40 00 76  | 返回值     
  | ------------------------ | 
  | 01 23 45 67 89 AB CD EF  | 保存的 %rbx
  | ------------------------ |   
  |			 8 byte			 |			
  | ------------------------ |
  |			 8 byte			 | <-- %rsp
  | ------------------------ |


  B. 当输入字符串: 0123456789012345678901234 时

  1. 为转16进制时

  | ------------------------------------------------------ |
  |	  00     00     00     00	 00      40   00->00 76->4 |	返回值
  | ------------------------------------------------------ |
  | 01->3  23->2  45->1  67->0  89->9  AB->8  CD->7  EF-6  |    保存的 %rbx
  | ------------------------------------------------------ |
  |	  5     4       3     2	     1       0      9     8    |
  |------------------------------------------------------- |
  |	  7     6       5     4	     3       2      1     0    |	<-- %rsp
  | ------------------------------------------------------ |

  2. 转成16进制: 字符 0~9 的 ASCII 代码是 Ox30 ~ 0x39 。

  | ------------------------------------------------------ |
  |	 00    00      00    00	    00      40     00    34    |	返回值
  | ------------------------------------------------------ |
  |  33    32      31    30     39      38     37    36    |    保存的 %rbx
  | ------------------------------------------------------ |
  |	 35    34      33    32	    31      30     39    38    |
  |------------------------------------------------------- |
  |	 37    36      35    34	    33      32     31    30    |	<-- %rsp
  | ------------------------------------------------------ |

  栈的成员变量内存分配是从低地址向高地址分配的, 
  
  在C语言中，字符串总是以'\0'作为结尾，所以'\0'也被称为字符串结束标志，或者字符串结束符。 也就是null字符, 其 ASCII 码是 0x00.

  字符串与数组:
	1. 字符串以'\0'作为结尾，而数组没有这个规定
	2. 字符串就是数组, 而数组不一定是字符串
	3. C语言在处理字符串时，会从前往后逐个扫描字符，一旦遇到'\0'就认为到达了字符串的末尾，就结束处理。'\0'至关重要，没有'\0'就意味着永远也到达不了字符串的结尾。
	4. 由" "包围的字符串会自动在末尾添加'\0'。例如，"abc123"从表面看起来只包含了 6 个字符，其实不然，C语言会在最后隐式地添加一个'\0'，这个过程是在后台默默地进行的，所以我们感受不到。
	5. "abc123"看起来只包含了 6 个字符，我们却将 str 的长度定义为 7，就是为了能够容纳最后的'\0'。如果将 str 的长度定义为 6，它就无法容纳'\0'了。
	6. 字符串长度，就是字符串包含了多少个字符（不包括最后的结束符'\0'）。例如"abc"的长度是 3，而不是 4。


  C. 
	当输入字符串: 0123456789012345678901234
	原来的返回值低位 76 被 34 覆盖, 所以程序试图返回地址为: 0x400034


  D.
	由 B 可知, 寄存器 %rbx 的值被覆盖破坏了

  E.get_line 函数还有哪些错误?

	对 malloc 的调用应该以 strlen(buf)+1 作为它的参数，而且代码还应该检查返回值是否为NULL。

*/

char* get_line() {
	char buf[4];
	char* result;
	gets(buf);
	malloc(strlen(buf));
	result = buf;
	strcpy(result, buf);
	return result;
}

/*
	char *get_line()
	0000000000400720 <get_line>:
	400720: 53  			push	%rbx
	400721: 48 83 ec 10		sub		$0x10, %rsp
	
	-- Diagram stack at this point

	400725 48 89 e7			mov		%rsp, %rdi
	400728: e8 73 ff ff ff	callq	4006a0 <gets>

	-- Modify diagram to show stack contents at this point

*/
char* gets(char* s) {
	int c;
	char* dest = s;
	while ((c = getchar()) != '\n' && c != EOF)
		*dest++ = c;
	if (c == EOF && dest == s)
		return NULL;
	*dest++ = '\0'; 
	return s;
}



